name: Build Debian Package

on:
  release:
    types: [published]
  workflow_run:
    workflows: ["Release"]
    types:
      - completed
  workflow_dispatch:
    inputs:
      tag_name:
        description: 'Release tag (example: v0.1.0)'
        required: false
        default: ''

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  build-deb-package:
    name: Build Debian Package (${{ matrix.arch }})
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'release' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    strategy:
      matrix:
        include:
          - arch: amd64
            target: x86_64-unknown-linux-gnu
          - arch: arm64
            target: aarch64-unknown-linux-gnu

    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Set up release variables
        id: vars
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            if [ -z "${{ github.event.inputs.tag_name }}" ]; then
              echo "Finding latest release tag..."
              RELEASE_TAG=$(gh api repos/${{ github.repository }}/releases/latest | jq -r '.tag_name')
            else
              RELEASE_TAG="${{ github.event.inputs.tag_name }}"
            fi
          elif [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "Triggered by Release workflow completion, finding latest release..."
            RELEASE_TAG=$(gh api repos/${{ github.repository }}/releases/latest | jq -r '.tag_name')
          else
            RELEASE_TAG=${{ github.event.release.tag_name }}
          fi

          VERSION=${RELEASE_TAG#v}
          echo "RELEASE_TAG=$RELEASE_TAG" >> $GITHUB_ENV
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Using release tag: $RELEASE_TAG and version: $VERSION"

      - name: Setup GitHub CLI
        run: |
          gh auth login --with-token <<< "${{ secrets.GITHUB_TOKEN }}"

      - name: Download release assets
        run: |
          # Create a directory for the assets
          mkdir -p release-assets

          # Download the artifact for this architecture
          gh release download ${{ env.RELEASE_TAG }} -p "*${{ matrix.target }}*.tar.gz" -D release-assets

          # List the downloaded files
          ls -la release-assets

          # Copy file to working directory
          cp release-assets/*${{ matrix.target }}*.tar.gz nuxbe-printer-bridge-${{ matrix.target }}.tar.gz

      - name: Create package directory structure
        run: |
          mkdir -p mypackage/DEBIAN
          mkdir -p mypackage/usr/bin
          mkdir -p mypackage/lib/systemd/system

      - name: Extract binary artifacts
        run: |
          tar -xzf nuxbe-printer-bridge-${{ matrix.target }}.tar.gz -C mypackage/usr/bin/
          # Rename the binary if needed (release.yml creates rust-spooler)
          if [ -f mypackage/usr/bin/rust-spooler ]; then
            mv mypackage/usr/bin/rust-spooler mypackage/usr/bin/nuxbe-printer-bridge
          fi
          chmod +x mypackage/usr/bin/nuxbe-printer-bridge

      - name: Create systemd service file
        run: |
          cat > mypackage/lib/systemd/system/nuxbe-printer-bridge.service << 'EOF'
          [Unit]
          Description=Nuxbe Printer Bridge Service
          After=network.target cups.service
          Requires=cups.service
          Documentation=https://github.com/Team-Nifty-GmbH/nuxbe-printer-bridge

          [Service]
          Type=simple
          User=root
          ExecStart=/usr/bin/nuxbe-printer-bridge run
          Restart=on-failure
          RestartSec=10
          StandardOutput=journal
          StandardError=journal
          Environment="RUST_BACKTRACE=1"

          [Install]
          WantedBy=multi-user.target
          EOF

      - name: Create Debian control files
        run: |
          # Create control file
          cat > mypackage/DEBIAN/control << EOF
          Package: nuxbe-printer-bridge
          Version: $VERSION
          Section: utils
          Priority: optional
          Architecture: ${{ matrix.arch }}
          Maintainer: Team Nifty GmbH <packages@team-nifty.com>
          Depends: cups, cups-client
          Description: Nuxbe ERP to CUPS Print Server Bridge
           A bridge between Nuxbe ERP and CUPS printing system
           to manage printers and handle print jobs. It provides
           a REST API, real-time WebSocket integration, and
           automatic synchronization between systems.
          EOF

          # Create post-installation script
          cat > mypackage/DEBIAN/postinst << 'EOF'
          #!/bin/sh
          set -e

          if [ "$1" = "configure" ] || [ "$1" = "abort-upgrade" ]; then
              # Make sure the binary is executable
              chmod +x /usr/bin/nuxbe-printer-bridge

              # Create config directory if it doesn't exist
              mkdir -p /etc/nuxbe-printer-bridge

              # Reload systemd to recognize the new service file
              systemctl daemon-reload >/dev/null 2>&1 || true

              # Enable service but don't start it
              echo "Nuxbe Printer Bridge has been installed but not started."
              echo "Configure the service with: nuxbe-printer-bridge config"
              echo "Then start it with: systemctl start nuxbe-printer-bridge.service"
              echo "To enable at boot: systemctl enable nuxbe-printer-bridge.service"
          fi

          exit 0
          EOF
          chmod 755 mypackage/DEBIAN/postinst

          # Create pre-removal script
          cat > mypackage/DEBIAN/prerm << 'EOF'
          #!/bin/sh
          set -e

          if [ "$1" = "remove" ]; then
              # Stop the service if it's running
              systemctl stop nuxbe-printer-bridge.service >/dev/null 2>&1 || true
              systemctl disable nuxbe-printer-bridge.service >/dev/null 2>&1 || true
          fi

          exit 0
          EOF
          chmod 755 mypackage/DEBIAN/prerm

          # Create empty config directory and file for conffiles reference
          mkdir -p mypackage/etc/nuxbe-printer-bridge
          touch mypackage/etc/nuxbe-printer-bridge/config.json

          # Create conffiles
          cat > mypackage/DEBIAN/conffiles << 'EOF'
          /etc/nuxbe-printer-bridge/config.json
          EOF

      - name: Build Debian package
        run: |
          dpkg-deb --build mypackage
          PKG_NAME="nuxbe-printer-bridge_${VERSION}_${{ matrix.arch }}.deb"
          mv mypackage.deb "$PKG_NAME"
          echo "PACKAGE_NAME=$PKG_NAME" >> $GITHUB_ENV

      - name: Upload Debian package to release
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: ${{ env.PACKAGE_NAME }}
          asset_name: ${{ env.PACKAGE_NAME }}
          tag: ${{ env.RELEASE_TAG }}
          overwrite: true

  deploy-to-apt-repo:
    name: Deploy to APT Repository
    needs: build-deb-package
    runs-on: ubuntu-latest

    steps:
      - name: Set up release variables
        id: vars
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            if [ -z "${{ github.event.inputs.tag_name }}" ]; then
              RELEASE_TAG=$(gh api repos/${{ github.repository }}/releases/latest | jq -r '.tag_name')
            else
              RELEASE_TAG="${{ github.event.inputs.tag_name }}"
            fi
          elif [ "${{ github.event_name }}" = "workflow_run" ]; then
            RELEASE_TAG=$(gh api repos/${{ github.repository }}/releases/latest | jq -r '.tag_name')
          else
            RELEASE_TAG=${{ github.event.release.tag_name }}
          fi
          echo "RELEASE_TAG=$RELEASE_TAG" >> $GITHUB_ENV
          echo "Using release tag: $RELEASE_TAG"

      - name: Download all .deb packages from release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          mkdir -p packages
          gh release download ${{ env.RELEASE_TAG }} -p "*.deb" -D packages -R ${{ github.repository }}
          ls -la packages/

      - name: Deploy to repository server
        env:
          DEPLOY_KEY: ${{ secrets.DEPLOY_KEY }}
          REPO_HOST: ${{ secrets.REPO_HOST }}
        run: |
          if [ -z "$DEPLOY_KEY" ] || [ -z "$REPO_HOST" ]; then
            echo "DEPLOY_KEY or REPO_HOST not set, skipping deployment"
            exit 0
          fi

          # Set up SSH
          mkdir -p ~/.ssh
          echo "$DEPLOY_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H "$REPO_HOST" >> ~/.ssh/known_hosts

          # Upload packages
          scp -i ~/.ssh/deploy_key packages/*.deb deploy@$REPO_HOST:/tmp/

          # Update repository
          ssh -i ~/.ssh/deploy_key deploy@$REPO_HOST 'sudo /opt/nuxbe-printer-bridge/repo-setup/scripts/update-repo.sh'