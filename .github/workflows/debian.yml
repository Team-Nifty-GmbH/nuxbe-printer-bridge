name: Build Debian Package

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      tag_name:
        description: 'Release tag (example: v0.1.0)'
        required: false
        default: ''

jobs:
  build-deb-package:
    name: Build Debian Package
    runs-on: ubuntu-latest

    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Set up release variables
        id: vars
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            if [ -z "${{ github.event.inputs.tag_name }}" ]; then
              echo "Finding latest release tag..."
              RELEASE_TAG=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                "https://api.github.com/repos/${{ github.repository }}/releases/latest" | \
                jq -r '.tag_name')
            else
              RELEASE_TAG="${{ github.event.inputs.tag_name }}"
            fi
          else
            RELEASE_TAG=${GITHUB_REF#refs/tags/}
          fi
          
          VERSION=${RELEASE_TAG#v}
          echo "RELEASE_TAG=$RELEASE_TAG" >> $GITHUB_ENV
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Using release tag: $RELEASE_TAG and version: $VERSION"

      - name: Setup GitHub CLI
        run: |
          echo "Installing GitHub CLI"
          # Print GitHub token's first few characters to check it exists (avoid printing the whole token)
          echo "GitHub token check: ${GITHUB_TOKEN:0:5}..." 
          gh auth status || gh auth login --with-token <<< "${{ secrets.GITHUB_TOKEN }}"

      - name: Debug release info
        run: |
          echo "Looking for release: ${{ env.RELEASE_TAG }}"
          gh release list

      - name: Download release assets
        run: |
          # Create a directory for the assets
          mkdir -p release-assets
          
          # Try to download with more verbose output
          gh release download "${{ env.RELEASE_TAG }}" -p "*x86_64*.tar.gz" -D release-assets --verbose || echo "x86_64 asset not found"
          gh release download "${{ env.RELEASE_TAG }}" -p "*aarch64*.tar.gz" -D release-assets --verbose || echo "aarch64 asset not found"
          
          # List what was actually downloaded
          ls -la release-assets || echo "No assets directory or it's empty"
          
          # Check if we have the required files
          if [ ! -f "$(find release-assets -name "*x86_64*.tar.gz" | head -1)" ] || [ ! -f "$(find release-assets -name "*aarch64*.tar.gz" | head -1)" ]; then
            echo "Required assets not found! Exiting."
            exit 1
          fi
          
          # Copy files to working directory with expected names
          cp $(find release-assets -name "*x86_64*.tar.gz" | head -1) rust-spooler-x86_64-unknown-linux-musl.tar.gz
          cp $(find release-assets -name "*aarch64*.tar.gz" | head -1) rust-spooler-aarch64-unknown-linux-musl.tar.gz

      - name: Create package directory structure
        run: |
          mkdir -p mypackage/DEBIAN
          mkdir -p mypackage/usr/lib/flux-cups-spooler/x86_64
          mkdir -p mypackage/usr/lib/flux-cups-spooler/arm64
          mkdir -p mypackage/usr/bin
          mkdir -p mypackage/lib/systemd/system

      - name: Extract binary artifacts
        run: |
          tar -xzf rust-spooler-x86_64-unknown-linux-musl.tar.gz -C mypackage/usr/lib/flux-cups-spooler/x86_64/
          tar -xzf rust-spooler-aarch64-unknown-linux-musl.tar.gz -C mypackage/usr/lib/flux-cups-spooler/arm64/
          chmod +x mypackage/usr/lib/flux-cups-spooler/x86_64/rust-spooler
          chmod +x mypackage/usr/lib/flux-cups-spooler/arm64/rust-spooler

      - name: Create wrapper script
        run: |
          cat > mypackage/usr/bin/rust-spooler << 'EOF'
          #!/bin/sh
          # Architecture detection script for rust-spooler
          
          ARCH=$(dpkg --print-architecture)
          if [ "$ARCH" = "arm64" ]; then
              exec /usr/lib/flux-cups-spooler/arm64/rust-spooler "$@"
          else
              exec /usr/lib/flux-cups-spooler/x86_64/rust-spooler "$@"
          fi
          EOF
          chmod +x mypackage/usr/bin/rust-spooler

      - name: Create systemd service file
        run: |
          cat > mypackage/lib/systemd/system/flux-spooler.service << 'EOF'
          [Unit]
          Description=FLUX ERP Print Spooler Service
          After=network.target cups.service
          Requires=cups.service
          Documentation=https://github.com/Team-Nifty-GmbH/flux-rust-spooler
          
          [Service]
          Type=simple
          User=root
          ExecStart=/usr/bin/rust-spooler run
          Restart=on-failure
          RestartSec=10
          StandardOutput=journal
          StandardError=journal
          Environment="RUST_BACKTRACE=1"
          
          [Install]
          WantedBy=multi-user.target
          EOF

      - name: Create Debian control files
        run: |
          # Create control file with FIXED architecture string (no spaces)
          cat > mypackage/DEBIAN/control << EOF
          Package: flux-cups-spooler
          Version: $VERSION
          Section: utils
          Priority: optional
          Architecture: all
          Maintainer: Team Nifty <team@example.com>
          Depends: cups, cups-client, libssl-dev
          Description: FLUX ERP to CUPS Print Server
           A bridge between FLUX ERP and CUPS printing system
           to manage printers and handle print jobs. It provides
           a REST API, real-time WebSocket integration, and 
           automatic synchronization between systems.
          EOF

          # Create post-installation script
          cat > mypackage/DEBIAN/postinst << 'EOF'
          #!/bin/sh
          set -e

          if [ "$1" = "configure" ] || [ "$1" = "abort-upgrade" ]; then
              # Make sure the wrapper script is executable
              chmod +x /usr/bin/rust-spooler

              # Create config directory if it doesn't exist
              mkdir -p /etc/flux-spooler

              # Reload systemd to recognize the new service file
              systemctl daemon-reload >/dev/null 2>&1 || true

              # Enable service but don't start it
              echo "Flux print spooler service has been installed but not started."
              echo "Configure the service with: rust-spooler config"
              echo "Then start it with: systemctl start flux-spooler.service"
              echo "To enable at boot: systemctl enable flux-spooler.service"
          fi

          exit 0
          EOF
          chmod 755 mypackage/DEBIAN/postinst

          # Create pre-removal script
          cat > mypackage/DEBIAN/prerm << 'EOF'
          #!/bin/sh
          set -e

          if [ "$1" = "remove" ]; then
              # Stop the service if it's running
              systemctl stop flux-spooler.service >/dev/null 2>&1 || true
              systemctl disable flux-spooler.service >/dev/null 2>&1 || true
          fi

          exit 0
          EOF
          chmod 755 mypackage/DEBIAN/prerm

          # Create empty config directory and file for conffiles reference
          mkdir -p mypackage/etc/flux-spooler
          touch mypackage/etc/flux-spooler/config.json

          # Create conffiles
          cat > mypackage/DEBIAN/conffiles << 'EOF'
          /etc/flux-spooler/config.json
          EOF

      - name: Build Debian package
        run: |
          dpkg-deb --build mypackage
          PKG_NAME="flux-cups-spooler_${VERSION}_multi.deb"
          mv mypackage.deb "$PKG_NAME"
          echo "PACKAGE_NAME=$PKG_NAME" >> $GITHUB_ENV

      - name: Upload Debian package to release
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: ${{ env.PACKAGE_NAME }}
          asset_name: ${{ env.PACKAGE_NAME }}
          tag: ${{ env.RELEASE_TAG }}
          overwrite: true